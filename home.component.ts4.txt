import { Component, ElementRef, OnInit, ViewChild } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';

@Component({
  selector: 'app-home',
  template: `
    <div
      style="display: flex; justify-content: space-between; align-items: center; height: 100vh;"
    >
      <div class="col-md-4">
        <canvas #canvas></canvas>
      </div>
      <div class="col-md-4">
        <form
          [formGroup]="otherDataForm"
          (ngSubmit)="onSubmit()"
          class="form-group mb-3"
        >
          <label for="width" class="mr-2">Dikdörtgenin genişliği (mm):</label>
          <input
            type="number"
            id="width"
            name="width"
            class="form-control form-control-sm"
            formControlName="width"
          />

          <label for="height" class="mr-2">Dikdörtgenin yüksekliği (mm):</label>
          <input
            type="number"
            id="height"
            name="height"
            class="form-control form-control-sm"
            formControlName="height"
          />

          <ng-container
            *ngIf="
              otherDataForm.controls['width'].value > 0 &&
              otherDataForm.controls['height'].value > 0
            "
          >
            <label for="horizontalLines" class="mr-2"
              >Yatayda kaç adet çizgi olsun:</label
            >
            <input
              type="number"
              id="horizontalLines"
              name="horizontalLines"
              class="form-control form-control-sm"
              formControlName="horizontalLines"
            />

            <label for="verticalLines" class="mr-2"
              >Dikeyde kaç adet çizgi olsun:</label
            >
            <input
              type="number"
              id="verticalLines"
              name="verticalLines"
              class="form-control form-control-sm"
              formControlName="verticalLines"
            />

            <ng-container
              *ngIf="
                otherDataForm.controls['horizontalLines'].value > 0 &&
                otherDataForm.controls['verticalLines'].value > 0
              "
            >
              <div formGroupName="horizontalDistances">
                <ng-container
                  *ngFor="
                    let line of this.getLinesArray(
                      otherDataForm.controls['horizontalLines'].value
                    );
                    let i = index
                  "
                >
                  <!-- this anahtar kelimesini ekledim -->
                  <label>
                    {{
                      i === 0
                        ? 'Yataydaki 1. çizginin dikdörtgen ile arasındaki mesafe kaç mm olmalı:'
                        : 'Yataydaki ' +
                          (i + 1) +
                          '. çizginin ' +
                          i +
                          '. çizgi ile arasındaki mesafe kaç mm olmalı:'
                    }}
                    <input
                      type="number"
                      name="{{ 'distance_' + i }}"
                      class="form-control form-control-sm"
                      formControlName="{{ 'distance_' + i }}"
                    />
                  </label>
                </ng-container>
              </div>

              <div formGroupName="verticalDistances">
                <ng-container
                  *ngFor="
                    let line of this.getLinesArray(
                      otherDataForm.controls['verticalLines'].value
                    );
                    let i = index
                  "
                >
                  <!-- this anahtar kelimesini ekledim -->
                  <label>
                    {{
                      i === 0
                        ? 'Dikeyde 1. çizginin dikdörtgen ile arasındaki mesafe kaç mm olmalı:'
                        : 'Dikeyde ' +
                          (i + 1) +
                          '. çizginin ' +
                          i +
                          '. çizgi ile arasındaki mesafe kaç mm olmalı:'
                    }}
                    <input
                      type="number"
                      name="{{ 'distance_' + i }}"
                      class="form-control form-control-sm"
                      formControlName="{{ 'distance_' + i }}"
                    />
                  </label>
                </ng-container>
              </div>
            </ng-container>
          </ng-container>

          <button type="submit" class="btn btn-primary">Gönder</button>
        </form>
      </div>
    </div>
  `,
})
export class HomeComponent implements OnInit {
  @ViewChild('canvas') canvas!: ElementRef<HTMLCanvasElement>;
  otherDataForm: FormGroup;

  constructor(private formBuilder: FormBuilder) {
    this.otherDataForm = this.formBuilder.group({
      width: null,
      height: null,
      horizontalLines: null,
      verticalLines: null,
      horizontalDistances: this.formBuilder.group({}),
      verticalDistances: this.formBuilder.group({}),
    });
  }

  ngOnInit(): void {
    // Subscribe to valueChanges observable of horizontalLines form control
    this.otherDataForm
      .get('horizontalLines')
      ?.valueChanges.subscribe((value) => {
        // Call addHorizontalDistances() with the new value of horizontalLines form control
        this.addHorizontalDistances(value);
      });

    // Subscribe to valueChanges observable of verticalLines form control
    this.otherDataForm.get('verticalLines')?.valueChanges.subscribe((value) => {
      // Call addVerticalDistances() with the new value of verticalLines form control
      this.addVerticalDistances(value);
    });

    // Subscribe to valueChanges observable of otherDataForm and call drawRectangle() method when any value changes.
    this.otherDataForm.valueChanges.subscribe(() => {
      this.drawRectangle();
    });
  }

  ngAfterViewInit(): void {
    // Set initial size of canvas element.
    const canvas = this.canvas.nativeElement;
    canvas.width = 800;
    canvas.height = 600;
  }

  onSubmit(): void {
    // Access the values of distances for horizontal and vertical lines
    const horizontalDistances = this.otherDataForm.value.horizontalDistances;
    const verticalDistances = this.otherDataForm.value.verticalDistances;

    // Log the distances for horizontal and vertical lines
    console.log('Horizontal Distances:', horizontalDistances);
    console.log('Vertical Distances:', verticalDistances);

    // Clear the form after submission (optional)
    this.otherDataForm.reset();
  }

  getLinesArray(lineCount: number): number[] {
    return Array(lineCount)
      .fill(0)
      .map((_, index) => index + 1);
  }

  addHorizontalDistances(count: number): void {
    const horizontalDistances = this.otherDataForm.get(
      'horizontalDistances'
    ) as FormGroup;
    horizontalDistances.reset();
    for (let i = 0; i < count; i++) {
      horizontalDistances.addControl(
        `distance_${i}`,
        this.formBuilder.control(null)
      );
    }
  }

  addVerticalDistances(count: number): void {
    const verticalDistances = this.otherDataForm.get(
      'verticalDistances'
    ) as FormGroup;
    verticalDistances.reset();
    for (let i = 0; i < count; i++) {
      verticalDistances.addControl(
        `distance_${i}`,
        this.formBuilder.control(null)
      );
    }
  }
  drawRectangle(): void {
    let width = this.otherDataForm.value.width;
    let height = this.otherDataForm.value.height;
    const horizontalDistances = this.otherDataForm.value.horizontalDistances;
    const verticalDistances = this.otherDataForm.value.verticalDistances;

    if (!width || !height) return;

    const canvas = this.canvas.nativeElement;
    const ctx = canvas.getContext('2d');

    if (!ctx) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Scale down rectangle and text if necessary
    let scale = 1;

    if (width > canvas.width - 20 || height > canvas.height - 20) {
      scale = Math.max(0.1, Math.min((canvas.width - 20) / width, (canvas.height - 20) / height));
      width *= scale;
      height *= scale;

      // Scale relative to center of canvas
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.scale(scale, scale);
      ctx.translate(-canvas.width / (2 * scale), -canvas.height / (2 * scale));
    }

    const offsetX = (canvas.width / scale - width) / 2;
    const offsetY = (canvas.height / scale - height) / 2;

    ctx.beginPath();
    ctx.rect(offsetX, offsetY, width, height);
    ctx.stroke();

    ctx.font = '16px sans-serif';

     // Ensure text stays within canvas
     let textWidth=ctx.measureText(`Width: ${width/scale}mm`).width;

     let textX=Math.min(width+20+offsetX,(canvas.width-textWidth-10)/scale);

     // Position text next to bottom side of rectangle
     ctx.fillText(`Width: ${width/scale}mm`,width/(2*scale)+offsetX-textWidth/2,height+offsetY+20);

     textWidth=ctx.measureText(`Height: ${height/scale}mm`).width;

     let textY=Math.min(height+30+offsetY,(canvas.height-10)/scale);

     // Position text next to right side of rectangle
     ctx.fillText(`Height: ${height/scale}mm`,width+offsetX+10,height/(2*scale)+offsetY);

     let currentY=offsetY;

     for(const key in horizontalDistances){
       const distance=horizontalDistances[key];
       if(distance!==null){
         currentY+=distance;
         const isBeyondBounds=currentY>height+offsetY;

         ctx.beginPath();
         ctx.moveTo(offsetX,currentY);
         ctx.lineTo(width+offsetX,currentY);
         ctx.strokeStyle=isBeyondBounds?'red':'black';
         ctx.stroke();

         textWidth=ctx.measureText(`${distance}mm`).width;

         textX=Math.min(width+Math.max(20,textWidth)+offsetX,(canvas.width-textWidth-10)/scale);

         ctx.fillStyle=isBeyondBounds?'red':'black';
         ctx.fillText(
           `${distance}mm`,
           textX,
           currentY
         );
       }
     }

     let currentX=offsetX;

     for(const key in verticalDistances){
       const distance=verticalDistances[key];
       if(distance!==null){
         currentX+=distance;
         const isBeyondBounds=currentX>width+offsetX;

         ctx.beginPath();
         ctx.moveTo(currentX,offsetY);
         ctx.lineTo(currentX,height+offsetY);
         ctx.strokeStyle=isBeyondBounds?'red':'black';
         ctx.stroke();

         textWidth=ctx.measureText(`${distance}mm`).width;

         textY=Math.min(height+Math.max(30,textWidth)+offsetY,(canvas.height-textWidth-10)/scale);

         ctx.fillStyle=isBeyondBounds?'red':'black';

         // Position text below center of line
         ctx.fillText(
           `${distance}mm`,
           currentX-textWidth/2,
           height+offsetY+20
         );
       }
     }

     // Reset canvas context
     ctx.setTransform(1,0,0,1,0,0);
  }











}
